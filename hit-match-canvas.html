<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Hit Match — Canvas</title>
<style>
  html,body{height:100%;margin:0}
  body{display:flex;align-items:center;justify-content:center;background:#0c0f16;color:#e7ecf3;font-family:system-ui, -apple-system, Segoe UI, Roboto}
  .wrap{display:flex;gap:14px;flex-wrap:wrap;align-items:flex-start;justify-content:center;padding:14px}
  .panel{background:#141a26;border-radius:14px;padding:12px;min-width:260px}
  h1{font-size:18px;margin:0 0 6px 0}
  .stat{display:flex;gap:10px;margin:8px 0 12px 0}
  .badge{background:#0f1320;border:1px solid #2a3356;border-radius:10px;padding:8px 10px}
  .row{display:flex;gap:8px;flex-wrap:wrap}
  button{background:#2a66ff;border:0;color:#fff;border-radius:10px;padding:10px 12px;font-weight:700}
  canvas{background:#101525;border-radius:16px;touch-action:none}
  .hint{color:#9aa4ba;font-size:12px;margin-top:8px}
</style>
</head>
<body>
<div class="wrap">
  <div class="panel">
    <h1>Hit Match — Canvas</h1>
    <div class="stat">
      <div class="badge">Score: <span id="score">0</span></div>
      <div class="badge">Moves: <span id="moves">30</span></div>
      <div class="badge">Goal: <span id="goal">3000</span></div>
    </div>
    <div class="row">
      <button id="new">New</button>
      <button id="shuffle">Shuffle</button>
      <button id="undo">Undo</button>
    </div>
    <div class="hint">Tap/drag to swap neighbors. Only swaps that make a match are allowed.</div>
  </div>
  <canvas id="game" width="640" height="640"></canvas>
</div>
<script>
(() => {
  const SIZE = 8, TILE = 72, GAP = 8;
  const MOVES_START = 30, GOAL = 3000;
  const TYPES = [
    {key:'BEY', name:'Bey', hue:50,  bg:'#f9d34e', fg:'#3e2a00'},
    {key:'FRE', name:'Fre', hue:280, bg:'#caa6ff', fg:'#1b0a33'},
    {key:'TAY', name:'Tay', hue:330, bg:'#ff9fbe', fg:'#340016'},
    {key:'MIC', name:'Mic', hue:200, bg:'#8fd3ff', fg:'#001d33'},
    {key:'ELV', name:'Elv', hue:180, bg:'#7ef0d4', fg:'#002a20'}
  ];

  const $ = s => document.querySelector(s);
  const canvas = $('#game'), ctx = canvas.getContext('2d');
  const scoreEl = $('#score'), movesEl = $('#moves'), goalEl = $('#goal');
  goalEl.textContent = GOAL;

  let grid = [];
  let score = 0, moves = MOVES_START;
  let history = [];
  let cell = 64, pad = 10;

  function randType(){ return (Math.random()*TYPES.length)|0; }

  function initGrid() {
    grid = Array.from({length: SIZE*SIZE}, randType);
    let changed = true, safety = 0;
    while (changed && safety < 500) {
      changed = false; safety++;
      for (let i=0;i<grid.length;i++) {
        if (isPartOfMatch(i)) { grid[i] = randType(); changed = true; }
      }
    }
  }

  function idx(r,c){ return r*SIZE+c; }
  function rc(i){ return [ (i/ SIZE) |0, i%SIZE ]; }

  function isMatchAt(r,c) {
    const t = grid[idx(r,c)];
    if (t==null) return false;
    let n=1;
    for(let cc=c-1; cc>=0 && grid[idx(r,cc)]===t; cc--) n++;
    for(let cc=c+1; cc<SIZE && grid[idx(r,cc)]===t; cc++) n++;
    if (n>=3) return true;
    n=1;
    for(let rr=r-1; rr>=0 && grid[idx(rr,c)]===t; rr--) n++;
    for(let rr=r+1; rr<SIZE && grid[idx(rr,c)]===t; rr++) n++;
    return n>=3;
  }
  function isPartOfMatch(i){ const [r,c]=rc(i); return isMatchAt(r,c); }

  function findMatches(){
    const m = new Set();
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const t = grid[idx(r,c)]; if (t==null) continue;
        let run=1; for(let cc=c+1; cc<SIZE && grid[idx(r,cc)]===t; cc++) run++;
        if (run>=3) for(let cc=c; cc<c+run; cc++) m.add(idx(r,cc));
        run=1; for(let rr=r+1; rr<SIZE && grid[idx(rr,c)]===t; rr++) run++;
        if (run>=3) for(let rr=r; rr<r+run; rr++) m.add(idx(rr,c));
      }
    }
    return m;
  }

  function collapseAndFill(){
    for(let c=0;c<SIZE;c++){
      const col=[];
      for(let r=0;r<SIZE;r++){ const v=grid[idx(r,c)]; if(v!=null) col.push(v); }
      while(col.length<SIZE) col.unshift(randType());
      for(let r=0;r<SIZE;r++) grid[idx(r,c)] = col[r];
    }
  }

  function drawTile(type, x, y, s){
    const t = TYPES[type];
    roundRect(x, y, s, s, 12, t=>{ ctx.fillStyle = '#1d2333'; ctx.fill(); });
    roundRect(x+6, y+6, s-12, s-12, 12, ()=>{ ctx.fillStyle = t.bg; ctx.fill(); });
    ctx.fillStyle = `hsl(${t.hue},70%,28%)`;
    ctx.beginPath(); ctx.moveTo(x+12, y+s*0.38);
    ctx.bezierCurveTo(x+18, y+10, x+s-18, y+10, x+s-12, y+s*0.38);
    ctx.lineTo(x+s-12, y+22);
    ctx.bezierCurveTo(x+s-28, y+10, x+28, y+10, x+12, y+22);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = `hsl(${t.hue},70%,50%)`;
    ctx.beginPath(); ctx.arc(x+s/2, y+s*0.60, s*0.22, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = t.fg;
    ctx.beginPath(); ctx.arc(x+s*0.44, y+s*0.59, 3, 0, Math.PI*2); ctx.arc(x+s*0.56, y+s*0.59, 3, 0, Math.PI*2); ctx.fill();
    ctx.strokeStyle = t.fg; ctx.lineWidth = 2.5; ctx.lineCap='round';
    ctx.beginPath(); ctx.moveTo(x+s*0.40, y+s*0.71); ctx.quadraticCurveTo(x+s*0.50, y+s*0.77, x+s*0.60, y+s*0.71); ctx.stroke();
    roundRect(x+s*0.25, y+s*0.78, s*0.50, s*0.16, 8, ()=>{ ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fill(); });
    ctx.fillStyle = t.fg; ctx.font = `bold ${Math.floor(s*0.14)}px system-ui`; ctx.textAlign='center'; ctx.textBaseline='middle';
    ctx.fillText(t.key, x+s/2, y+s*0.86);
  }

  function roundRect(x, y, w, h, r, draw){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+w, y, x+w, y+h, r);
    ctx.arcTo(x+w, y+h, x, y+h, r);
    ctx.arcTo(x, y+h, x, y, r);
    ctx.arcTo(x, y, x+w, y, r);
    ctx.closePath(); draw();
  }

  function draw() {
    fitCanvas();
    ctx.clearRect(0,0,canvas.width, canvas.height);
    ctx.fillStyle = '#0e1422'; ctx.fillRect(0,0,canvas.width, canvas.height);
    for(let r=0;r<SIZE;r++){
      for(let c=0;c<SIZE;c++){
        const x = pad + c*(cell+pad);
        const y = pad + r*(cell+pad);
        const t = grid[idx(r,c)];
        if (t!=null) drawTile(t, x, y, cell);
      }
    }
    scoreEl.textContent = score;
    movesEl.textContent = moves;
  }

  function fitCanvas(){
    const max = Math.min(640, Math.min(window.innerWidth-32, window.innerHeight-32));
    canvas.width = canvas.height = max>320 ? max : 320;
    const slots = SIZE;
    pad = Math.max(6, Math.floor(canvas.width * 0.01));
    cell = Math.floor((canvas.width - pad*(slots+1)) / slots);
  }
  window.addEventListener('resize', ()=>{ draw(); }, {passive:true});

  function swap(a,b){ const t=grid[a]; grid[a]=grid[b]; grid[b]=t; }

  function neighbors(i){
    const [r,c]=rc(i);
    const ns=[];
    if (r>0) ns.push(idx(r-1,c));
    if (r<SIZE-1) ns.push(idx(r+1,c));
    if (c>0) ns.push(idx(r,c-1));
    if (c<SIZE-1) ns.push(idx(r,c+1));
    return ns;
  }

  function makesAnyMatch(i,j){
    const cells = new Set([i,j,...neighbors(i),...neighbors(j)]);
    for(const k of cells){ const [r,c]=rc(k); if(isMatchAt(r,c)) return true; }
    return false;
  }

  function animateRemoval(matches, cb){
    const fading = Array.from(matches);
    const start = performance.now();
    function step(t){
      const k = Math.min(1, (t-start)/220);
      draw();
      ctx.globalAlpha = 1-k;
      for(const i of fading){
        const [r,c]=rc(i);
        const x = pad + c*(cell+pad), y = pad + r*(cell+pad);
        if (grid[i]!=null) drawTile(grid[i], x, y, cell);
      }
      ctx.globalAlpha = 1;
      if (k<1) requestAnimationFrame(step); else cb();
    }
    requestAnimationFrame(step);
  }

  function resolveBoard(){
    let combo=0;
    const loop=()=>{
      const matches = findMatches();
      if (matches.size===0){ draw(); checkEnd(); return; }
      combo++;
      score += 60 * matches.size * combo;
      animateRemoval(matches, ()=>{
        for(const i of matches) grid[i]=null;
        collapseAndFill();
        draw();
        setTimeout(loop, 40);
      });
    };
    draw();
    setTimeout(loop, 40);
  }

  function checkEnd(){
    if (moves<=0){
      setTimeout(()=>{ alert(score>=GOAL ? 'Level Clear!' : 'Out of moves!'); }, 10);
    }
  }

  let down = null, downXY=null;
  function pickCell(x,y){
    const c = Math.floor((x - pad) / (cell+pad));
    const r = Math.floor((y - pad) / (cell+pad));
    if (r<0||c<0||r>=SIZE||c>=SIZE) return null;
    return idx(r,c);
  }

  canvas.addEventListener('pointerdown', e => {
    const rect = canvas.getBoundingClientRect();
    down = pickCell(e.clientX-rect.left, e.clientY-rect.top);
    downXY = [e.clientX, e.clientY];
  });
  canvas.addEventListener('pointerup', e => {
    if (down==null) return;
    const rect = canvas.getBoundingClientRect();
    const up = pickCell(e.clientX-rect.left, e.clientY-rect.top);
    const dx = e.clientX - downXY[0], dy = e.clientY - downXY[1];
    let target = up;
    if (target==null || target===down || !neighbors(down).includes(target)){
      const [r,c] = rc(down);
      if (Math.abs(dx) > Math.abs(dy)){
        if (dx>16 && c<SIZE-1) target = idx(r,c+1);
        else if (dx<-16 && c>0) target = idx(r,c-1);
      }else{
        if (dy>16 && r<SIZE-1) target = idx(r+1,c);
        else if (dy<-16 && r>0) target = idx(r-1,c);
      }
    }
    if (target!=null && neighbors(down).includes(target)){
      history.push({grid:grid.slice(), score, moves});
      swap(down, target);
      if (!makesAnyMatch(down, target)){
        swap(down, target);
      } else {
        moves--;
        resolveBoard();
      }
    }
    down=null; downXY=null;
  }, {passive:true});

  $('#new').addEventListener('click', newGame);
  $('#shuffle').addEventListener('click', ()=>{
    history.push({grid:grid.slice(), score, moves});
    grid.sort(()=>Math.random()-0.5); draw();
  });
  $('#undo').addEventListener('click', ()=>{
    const last = history.pop();
    if (!last) return;
    grid = last.grid.slice(); score = last.score; moves = last.moves; draw();
  });

  function newGame(){ score = 0; moves = MOVES_START; history=[]; initGrid(); draw(); }
  newGame();
})();
</script>
</body>
</html>
